#+TITLE: Doom CORE
#+AUTHOR: Artem Smaznov
#+DESCRIPTION: Core configuration for Doom Vim
#+STARTUP: overview
#+PROPERTY: header-args :tangle core.vim

* Table of Contents :toc:
- [[#core][Core]]
- [[#helper-functions][Helper functions]]
- [[#editor][Editor]]
  - [[#general-abbreviations][General abbreviations]]
  - [[#search][Search]]
  - [[#files-backups-and-undo][Files, Backups and Undo]]
  - [[#ignore-compiled-files][Ignore Compiled Files]]
  - [[#text-tab-and-indent-related][Text, tab and indent related]]
  - [[#tabs-windows-and-buffers][Tabs, windows and buffers]]
  - [[#mouse][Mouse]]
  - [[#sound][Sound]]
  - [[#backspace][Backspace]]
  - [[#sudo-save][Sudo Save]]
  - [[#spell-checking][Spell Checking]]
- [[#file-handling][File Handling]]
  - [[#file-types][File Types]]
- [[#syntax-highlighting][Syntax highlighting]]
  - [[#ssh-hosts][SSH Hosts]]
- [[#ui][UI]]
  - [[#color-scheme][Color Scheme]]
  - [[#fonts][Fonts]]
  - [[#visual-elements][Visual Elements]]
  - [[#remove-separator-pipes][Remove separator pipes]]
  - [[#disable-scroll-bars][Disable Scroll-bars]]
  - [[#terminal-colors][Terminal Colors]]
  - [[#gui-mode][GUI Mode]]
- [[#keybindings][Keybindings]]
  - [[#leader---leader][Leader - <Leader>]]
  - [[#command-mode][Command Mode]]
  - [[#arrows][Arrows]]
  - [[#numbers][Numbers]]
  - [[#folds][Folds]]
  - [[#visual-selection-search][Visual Selection Search]]
  - [[#moving-lines][Moving Lines]]

* Core
Enable file type plugins
#+begin_src vimrc
filetype plugin on
filetype indent on
#+end_src

Leader Key
With a map leader it's possible to do extra key combinations
#+begin_src vimrc
let g:mapleader = " "
let g:maplocalleader = ","
#+end_src

Sources
#+begin_src vimrc
source $HOME/.vim/core/core-editor.vim
source $HOME/.vim/packages.vim
source $HOME/.vim/core/core-ui.vim
source $HOME/.vim/core/core-keybindings.vim
#+end_src

* Helper functions
#+begin_src vimrc
" Returns true if paste mode is enabled
function! HasPaste()
  if &paste
    return 'PASTE MODE  '
  endif
  return ''
endfunction

" Don't close window, when deleting a buffer
command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
  let l:currentBufNum = bufnr("%")
  let l:alternateBufNum = bufnr("#")

  if buflisted(l:alternateBufNum)
    buffer #
  else
    bnext
  endif

  if bufnr("%") == l:currentBufNum
    new
  endif

  if buflisted(l:currentBufNum)
    execute("bdelete! ".l:currentBufNum)
  endif
endfunction

function! CmdLine(str)
  call feedkeys(":" . a:str)
endfunction 

function! VisualSelection(direction, extra_filter) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", "\\/.*'$^~[]")
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'gv'
    call CmdLine("Ack '" . l:pattern . "' " )
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

func! DeleteTillSlash()
  let g:cmd = getcmdline()

  if has("win16") || has("win32")
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  endif

  if g:cmd == g:cmd_edited
    if has("win16") || has("win32")
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    endif
  endif   

  return g:cmd_edited
endfunc

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc
#+end_src

* Editor
:PROPERTIES:
:header-args: :tangle core-editor.vim
:END:
** General abbreviations
#+begin_src vimrc
iab xdate <C-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
#+end_src

** Search
#+begin_src vimrc
set ignorecase " Ignore case when searching
set smartcase  " When searching try to be smart about cases
set hlsearch   " Highlight search results
set incsearch  " Makes search act like search in modern browsers
set magic      " For regular expressions turn magic on

set wildmenu   " Turn on the Wild menu
#+end_src

** Files, Backups and Undo
#+begin_src vimrc
set nobackup              " This is recommended by coc
set nowritebackup         " This is recommended by coc
set noswapfile

set history=500       " Sets how many lines of history VIM has to remember
set clipboard=unnamed " Copy paste between vim and everything else

" Set to auto read when a file is changed from the outside
set autoread
" au FocusGained,BufEnter * checktime
au FocusGained * checktime

" Turn persistent undo on - you can undo even when you close a buffer/VIM
try
  set undodir=$HOME/.vim/temp_dirs/undodir
  set undofile
catch
endtry
#+end_src

** Ignore Compiled Files
#+begin_src vimrc
set wildignore=*.o,*~,*.pyc
if has("win16") || has("win32")
  set wildignore+=.git\*,.hg\*,.svn\*,**\node_modules\**
else
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,**/node_modules/**,*/.DS_Store
endif
#+end_src

** Text, tab and indent related
#+begin_src vimrc
set tabstop=2             " Insert 2 spaces for a tab
set shiftwidth=2          " Change the number of spaces for indentation
set smarttab              " Makes tabbing smarter will realize you have 2 vs 4
set expandtab             " Converts tabs to spaces

" Linebreak on 500 characters
set linebreak
" set textwidth=500

set autoindent  " Good auto indent
set smartindent " Makes indenting smart
set wrap        " Wrap lines

" CTRL+A/X will only treat numbers as decimals or hex
set nrformats=bin,hex
#+end_src

** Tabs, windows and buffers
#+begin_src vimrc
set hidden     " A buffer becomes hidden when it is abandoned

" Specify the behavior when switching between buffers 
try
  set switchbuf=useopen,usetab,newtab
  set stal=2
catch
endtry

" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" Delete trailing white space on save, useful for some filetypes
fun! CleanExtraSpaces()
  let save_cursor = getpos(".")
  let old_query = getreg('/')
  silent! %s/\s\+$//e
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfun

if has("autocmd")
  autocmd BufWritePre *.txt,*.js,*.py,*.wiki,*.sh,*.coffee :call CleanExtraSpaces()
endif
#+end_src

** Mouse
Enable Mouse Support
#+begin_src vimrc
set mouse=a

if !has('nvim')
  set ttymouse=sgr
  set termwinsize=15x0 " Set size for terminal
endif

set lazyredraw " Don't redraw while executing macros (good performance config)
set showmatch  " Show matching brackets when text indicator is over them
set mat=2      " How many tenths of a second to blink when matching brackets
#+end_src

** Sound
No annoying sound on errors
#+begin_src vimrc
set noerrorbells
set novisualbell
set t_vb=
set tm=500
#+end_src

Properly disable sound on errors on MacVim
#+begin_src vimrc
if has("gui_macvim")
  autocmd GUIEnter * set vb t_vb=
endif
#+end_src

** Backspace
Configure backspace so it acts as it should act
#+begin_src vimrc
set backspace=eol,start,indent
set whichwrap+=<,>,h,l
#+end_src

** Sudo Save
=:W= sudo saves the file
useful for handling the permission-denied error
#+begin_src vimrc
command! W execute 'w !sudo tee % > /dev/null' <bar> edit!
#+end_src

** Spell Checking
#+begin_src vimrc
set spelllang=en_us
#+end_src

* File Handling
#+begin_src vimrc
set encoding=utf-8 " Set utf8 as standard encoding and en_US as the standard language
set ffs=unix,dos,mac " Use Unix as the standard file type
#+end_src

** File Types
#+begin_src vimrc :tangle ../filetype.vim
au BufNewFile,BufRead known_hosts,authorized_keys,*.pub setfiletype sshhosts
#+end_src

* Syntax highlighting
Enable syntax highlighting
#+begin_src vimrc
syntax enable
#+end_src

** SSH Hosts
:PROPERTIES:
:header-args: :tangle ../syntax/sshhosts.vim
:END:
IP, Port or HostName
#+begin_src vimrc
syn match sshhost "\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}"
syn match sshhost ":\d\+"
syn match sshhost "[0-9a-zA-Z_-]\+@.\+"
#+end_src

Website
#+begin_src vimrc
syn match sshsite ".\+\(,\)\@="
#+end_src

Public SSH key
#+begin_src vimrc
syn match sshpubkey "AAAA[0-9a-zA-Z+/]\+[=]\{0,2}"
#+end_src

Define the default highlighting
#+begin_src vimrc
hi def link sshsite Statement
hi def link sshhost Special 
hi def link sshpubkey SpecialKey
#+end_src

* UI
:PROPERTIES:
:header-args: :tangle core-ui.vim
:END:
** Color Scheme
#+begin_src vimrc
set background=dark
colorscheme gruvbox8
#+end_src

** Fonts
#+begin_src vimrc
" Set font according to system
if has("mac") || has("macunix")
  set gfn=IBM\ Plex\ Mono:h14,Hack:h14,Source\ Code\ Pro:h15,Menlo:h15
elseif has("win16") || has("win32")
  set gfn=Hack\ Nerd\ Font\ Mono:h10,Source\ Code\ Pro:h12,IBM\ Plex\ Mono:h14,Consolas:h11
elseif has("gui_gtk2")
  set gfn=IBM\ Plex\ Mono\ 14,:Hack\ 14,Source\ Code\ Pro\ 12,Bitstream\ Vera\ Sans\ Mono\ 11
elseif has("linux")
  set gfn=IBM\ Plex\ Mono\ 14,:Hack\ 14,Source\ Code\ Pro\ 12,Bitstream\ Vera\ Sans\ Mono\ 11
elseif has("unix")
  set gfn=Monospace\ 11
endif
#+end_src

** Visual Elements
#+begin_src vimrc
set foldcolumn=1     " Add a bit extra margin to the left
set signcolumn=yes   " Always show the signcolumn, otherwise it would shift the text each time
set ruler            " Always show current position
set number           " Show line numbers
set relativenumber   " Make line numbers relative
set cursorline       " Enable highlighting of the current line
set showtabline=2    " Always show tabs
set laststatus=2     " Always display the status line
set showcmd          " Show commands
set cmdheight=1      " Height of the command bar
set splitbelow       " Horizontal splits will automatically be below
set splitright       " Vertical splits will automatically be to the right
#+end_src

** Remove separator pipes
#+begin_src vimrc
set fillchars+=vert:\ 
#+end_src

** Disable Scroll-bars 
#+begin_src vimrc
set guioptions-=r
set guioptions-=R
set guioptions-=l
set guioptions-=L
#+end_src

** Terminal Colors
Enable 256 colors palette in Gnome Terminal
#+begin_src vimrc
if $COLORTERM == 'gnome-terminal'
  set t_Co=256
endif
#+end_src

#+begin_src vimrc
if exists('$TMUX') 
  if has('nvim')
    set termguicolors
  else
    set term=screen-256color 
  endif
endif
#+end_src

** GUI Mode
Set extra options when running in GUI mode
#+begin_src vimrc
if has("gui_running")
  set guioptions-=T
  set guioptions-=e
  set t_Co=256
  set guitablabel=%M\ %t
endif
#+end_src

* Keybindings
:PROPERTIES:
:header-args: :tangle core-keybindings.vim
:END:
** Leader - <Leader>
*** Root
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map['<']     = 'Switch buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map['<Esc>'] = 'Clear search highlights' | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map['`']     = 'Switch to last buffer'   | endif

map <leader>< :BufExplorerHorizontalSplit<cr>
nnoremap <silent> <leader><Esc> :nohlsearch<cr>
map <leader>` :b#<cr>
#+end_src

*** TAB -> +workspace
#+begin_src vimrc
map <leader><Tab>. :tabs<cr>
map <leader><Tab>0 :$tabnext<cr>
map <leader><Tab>1 :1tabnext<cr>
map <leader><Tab>2 :2tabnext<cr>
map <leader><Tab>3 :3tabnext<cr>
map <leader><Tab>4 :4tabnext<cr>
map <leader><Tab>5 :5tabnext<cr>
map <leader><Tab>6 :6tabnext<cr>
map <leader><Tab>7 :7tabnext<cr>
map <leader><Tab>8 :8tabnext<cr>
map <leader><Tab>9 :9tabnext<cr>
map <leader><Tab>< :0tabmove<cr>
map <leader><Tab>> :$tabmove<cr>
map <leader><Tab>[ :tabprevious<cr>
map <leader><Tab>] :tabnext<cr>
map <leader><Tab>` :tabnext #<cr>
map <leader><Tab>c :tabclose<cr>
map <leader><Tab>d :tabclose<cr>
map <leader><Tab>m :tabmove
map <leader><Tab>n :tabnew<cr>
map <leader><Tab>O :tabonly<cr>
map <leader><Tab>{ :-tabmove<cr>
map <leader><Tab>} :+tabmove<cr>


" Toggle between this and the last accessed tab
let g:lasttab = 1
nmap <leader><Tab>l :exe "tabn ".g:lasttab<CR>
au TabLeave * let g:lasttab = tabpagenr()
#+end_src

*** b -> +buffer
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b      = { 'name' : '+buffer' }  | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['['] = 'Previous buffer'       | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b[']'] = 'Next buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['b'] = 'Switch buffer'         | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['d'] = 'Kill buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['k'] = 'Kill buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['K'] = 'Kill all buffers'      | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['n'] = 'Next buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['N'] = 'New empty tab'         | endif
" if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['O'] = 'Kill other buffers'    | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['p'] = 'Previous buffer'       | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['l'] = 'Switch to last buffer' | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['s'] = 'Save buffer'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['S'] = 'Save all buffers'      | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.b['u'] = 'Save buffer as root'   | endif

map <leader>b[ :bprevious<cr>
map <leader>b] :bnext<cr>
map <leader>bb :BufExplorerHorizontalSplit<cr>
map <leader>bd :Bclose<cr>
map <leader>bk :Bclose<cr>
map <leader>bK :bufdo bd<cr>
map <leader>bn :bnext<cr>
map <leader>bN :tabe<cr>
" map <leader>bO :<bar> %bd <bar> e#<cr>
map <leader>bp :bprevious<cr>
map <leader>bl :b#<cr>
map <leader>bs :write<cr>
map <leader>bS :wa<cr>
map <leader>bu :W<cr>
#+end_src

*** c -> +code
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.c = { 'name' : '+code' } | endif
#+end_src

*** f -> +file
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.f      = { 'name' : '+file' }      | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['c'] = 'CD to current directory' | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['s'] = 'Save file'               | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['S'] = 'Save as...'              | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['v'] = 'Grep'                    | endif

map <leader>fc :cd %:p:h<cr>:pwd<cr>
map <leader>fs :write<cr>
map <leader>fS :write
map <leader>fv :vimgrep **/*
#+end_src

FZF
#+begin_src vimrc
if has_key(plugs, 'fzf')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['f'] = 'Find file'    | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.f['r'] = 'Recent files' | endif

    map <leader>ff :Files<CR>
    map <leader>fr :History<CR>
endif
#+end_src

*** g -> +git
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.g      = { 'name' : '+git' } | endif
#+end_src

Git Gutter
#+begin_src vimrc
if has_key(plugs, 'vim-gitgutter')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.g['d'] = 'Diff Split'        | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.g['g'] = 'Status'            | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.g['p'] = 'Preview hunk'      | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.g['s'] = 'Stage hunk'        | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.g['u'] = 'Undo hunk'         | endif
    if has_key(plugs, 'vim-which-key') | let g:bracket_map.c        = 'Git Hunk'          | endif

    nnoremap <silent> <leader>gd :vertical Gdiffsplit<cr>
    nnoremap <silent> <leader>gg :Git<cr>

    nmap <leader>gp <Plug>(GitGutterPreviewHunk)
    map <leader>gs <Plug>(GitGutterStageHunk)
    nmap <leader>gu <Plug>(GitGutterUndoHunk)
endif
#+end_src

*** h -> +help
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.h = { 'name' : '+help' } | endif
#+end_src

FZF
#+begin_src vimrc
if has_key(plugs, 'fzf')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.h['b'] = 'Bindings'    | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.h['h'] = 'Search Help' | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.h['t'] = 'Load theme'  | endif

    map <leader>hb :Maps<CR>
    nnoremap <leader>hh :Helptags<CR>
    nnoremap <leader>ht :Colors<CR>
endif
#+end_src

**** R -> +Reload
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.h.r      = { 'name' : '+reload' } | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.h.r['e'] = 'Reload env'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.h.r['p'] = 'Reload plugins'       | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.h.r['r'] = 'Reload'               | endif

map <leader>hre :source $MYVIMRC<cr>
map <leader>hrr :source %<cr>
#+end_src

*** i -> +insert
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.i      = { 'name' : '+insert' } | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.i['t'] = 'Insert Toilet title'  | endif
#+end_src

*** o -> +open
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.o = { 'name' : '+open' } | endif
#+end_src

Float Term
#+begin_src vimrc
if has_key(plugs, 'vim-floaterm')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.o['`'] = 'Terminal' | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.o['p'] = 'Python'   | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.o['r'] = 'Ranger'   | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.o['v'] = 'Vifm'     | endif

    map <leader>o` :FloatermToggle<cr>
    map <leader>op :FloatermNew python<cr>
    map <leader>or :FloatermNew ranger<cr>
    map <leader>ov :FloatermNew vifm<cr>
endif
#+end_src

*** m -> +<localleader>
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.m = { 'name' : '+<localleader>' } | endif
#+end_src

*** p -> +popup (project)
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.p = { 'name' : '+popup' } | endif
#+end_src

FZF
#+begin_src vimrc
if has_key(plugs, 'fzf')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p["'"] = 'Search marks'        | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p['/'] = 'Search history'      | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p[':'] = 'Commands history'    | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p['b'] = 'Switch buffer'       | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p['c'] = 'Search all commands' | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p['f'] = 'Switch filetype'     | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.p['w'] = 'Switch window'       | endif

    nnoremap <leader>p' :Marks<CR>
    nnoremap <leader>p/ :History/<CR>
    nnoremap <leader>p: :History:<CR>
    map <leader>pb :Buffers<CR>
    map <leader>pc :Commands<CR>
    map <leader>pf :Filetypes<CR>
    map <leader>pw :Windows<CR>
endif
#+end_src

*** q -> +quit/session
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q      = { 'name' : '+quit/session' } | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['l'] = 'Quick load session'         | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['L'] = 'Load session from file'     | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['q'] = 'Quit Vim'                   | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['Q'] = 'Quit Vim without saving'    | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['s'] = 'Quick save current session' | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.q['S'] = 'Save session to file'       | endif

map <leader>ql :source $HOME/.vim/sessions/quick-session.vim<cr>
map <leader>qL :source $HOME/.vim/sessions/
map <leader>qq :qa<cr>
map <leader>qQ :qa!<cr>
map <leader>qs :mksession! $HOME/.vim/sessions/quick-session.vim<cr>
map <leader>qS :mksession $HOME/.vim/sessions/
#+end_src

*** s -> +search
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.s = { 'name' : '+search' } | endif
#+end_src

FZF
#+begin_src vimrc
if has_key(plugs, 'fzf')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.s['b'] = 'Search buffer'              | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.s['B'] = 'Search all open buffers'    | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.s['p'] = 'Search project'             | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.s['t'] = 'Search Tags in buffer'      | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.s['T'] = 'Search Tags in all buffers' | endif

    map <leader>sb :BLines<CR>
    map <leader>sB :Lines<CR>
    nnoremap <leader>sp :Rg<CR>
    nnoremap <leader>st :BTags<CR>
    nnoremap <leader>sT :Tags<CR>
endif
#+end_src

*** t -> +toggle
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.t      = { 'name' : '+toggle' } | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['p'] = 'Paste mode'           | endif 
if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['s'] = 'Spell check'          | endif 

map <leader>tp :setlocal paste!<cr>
map <leader>ts :setlocal spell!<cr>
map <leader>it :r !toilet -f pagga
#+end_src

Mini-map
#+begin_src vimrc
if has_key(plugs, 'vim-minimap')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['m']      = 'Minimap'                  | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['M']      = { 'name' : '+minimap...' } | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['M']['c'] = 'Close minimap'            | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['M']['o'] = 'Open minimap'             | endif
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['M']['u'] = 'Update minimap'           | endif
    
    let g:minimap_show='<leader>tMo'
    let g:minimap_update='<leader>tMu'
    let g:minimap_close='<leader>tMc'
    let g:minimap_toggle='<leader>tm'
endif
#+end_src

Colorizer
#+begin_src vimrc
if has_key(plugs, 'Colorizer')
    if has_key(plugs, 'vim-which-key') | let g:which_key_map.t['c'] = 'Color highlights' | endif
    
    nnoremap <leader>tc :ColorToggle<cr>
endif
#+end_src

*** w -> +window
#+begin_src vimrc
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w      = { 'name' : '+window' }       | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['+'] = 'Increase window height'     | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['-'] = 'Decrease window height'     | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['<'] = 'Decrease window width'      | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['='] = 'Balance windows'            | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['>'] = 'Increase window width'      | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['_'] = 'Set window height'          | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['`'] = 'Open a terminal in a split' | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['b'] = 'Bottom-right window'        | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['c'] = 'Close window'               | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['d'] = 'Close window'               | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['h'] = 'Left window'                | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['H'] = 'Move window left'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['j'] = 'Down window'                | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['J'] = 'Move window down'           | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['k'] = 'Up window'                  | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['K'] = 'Move window up'             | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['l'] = 'Right window'               | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['L'] = 'Move window right'          | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['n'] = 'New window'                 | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['o'] = 'Enlargen window'            | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['p'] = 'Last window'                | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['q'] = 'Quit window'                | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['r'] = 'Rotate windows downwards'   | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['R'] = 'Rotate windows upwards'     | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['s'] = 'Split window'               | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['S'] = 'Split and follow window'    | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['t'] = 'Top-left window'            | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['T'] = 'Tear off window'            | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['v'] = 'VSplit window'              | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['V'] = 'VSplit and follow window'   | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['w'] = 'Next window'                | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['W'] = 'Previous window'            | endif
if has_key(plugs, 'vim-which-key') | let g:which_key_map.w['|'] = 'Set window width'           | endif

map <leader>w+ :resize +5<cr>
map <leader>w- :resize -5<cr>
map <leader>w< :vertical resize -5<cr>
map <leader>w= <C-w>=
map <leader>w> :vertical resize +5<cr>
map <leader>w_ :resize<cr>
map <leader>w` :term<cr>
map <leader>wb <C-w>b
map <leader>wc :close<cr>
map <leader>wd :close<cr>
map <leader>wh <C-w>h
map <leader>wH <C-w>H
map <leader>wj <C-w>j
map <leader>wJ <C-w>J
map <leader>wk <C-w>k
map <leader>wK <C-w>K
map <leader>wl <C-w>l
map <leader>wL <C-w>L
map <leader>wn :new<cr>
map <leader>wo :only<cr>
map <leader>wp <C-w>p
map <leader>wq :quit<cr>
map <leader>wr <C-w>r
map <leader>wR <C-w>R
map <leader>ws :split<cr><C-w>p
map <leader>wS :split<cr>
map <leader>wt <C-w>t
map <leader>wT <C-w>T
map <leader>wv :vsplit<cr><C-w>p
map <leader>wV :vsplit<cr>
map <leader>ww <C-w>w
map <leader>wW <C-w>W
map <leader>w\| :vertical resize<cr>
#+end_src

** Command Mode
#+begin_src vimrc
map <A-x> :
#+end_src

** Arrows
#+begin_src vimrc
nnoremap <Up> :blast<cr>
nnoremap <Down> :bfirst<cr>
nnoremap <Left> :bprevious<cr>
nnoremap <Right> :bnext<cr>
#+end_src

** Numbers
Increment/Decrement number at point
#+begin_src vimrc
noremap g= <C-a>
noremap g- <C-x>
#+end_src

** Folds
#+begin_src vimrc
noremap <tab> :norm za<cr>
noremap <tab><tab> :norm zA<cr>
noremap <S-tab> :norm zR<cr>
noremap <S-tab><S-tab> :norm zM<cr>
#+end_src

** Visual Selection Search
#+begin_src vimrc
vnoremap <silent> * :<C-u>call VisualSelection('', '')<CR>/<C-R>=@/<CR><CR>
vnoremap <silent> # :<C-u>call VisualSelection('', '')<CR>?<C-R>=@/<CR><CR>
#+end_src

** Moving Lines
Move a line of text using Alt+j/k in all modes
#+begin_src vimrc
nnoremap <A-k> :m-2<cr>==
nnoremap <A-j> :m+<cr>==
vnoremap <A-k> :m '<-2<cr>gv=gv
vnoremap <A-j> :m '>+1<cr>gv=gv
#+end_src
